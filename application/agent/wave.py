# mathematical representation of waveform
from util import tobytes

class Wave:
    
    experiment = None   # reference to the experiment this wave belongs to

    waveID = None       # key generated by security functions
    E_final = None      # voltage at end of experiment
    wave_type = None    # type of wave sent whether all the points or just end points
    N = None            # number of times to repeat this wave
    n = None            # number of patterns in this wave

    patterns = []       # container for wave patterns

    points = []         # container for points to match up with current values in a data file

    def __init__(self, waveID=None, E_final=None, wave_type=None, N=None, n=None):
        self.waveID = waveID
        self.E_final = E_final
        self.wave_type = wave_type
        self.N = N
        self.n = n
        self.patterns = []

    def add_pattern(self, pattern):
        pattern.wave = self
        self.patterns.append(pattern)

    def marshall(self): #pack up wave into an array of values

        # Wave marshalling documentation:
        # Wave: waveID, E_final, N, n, (Pattern)*
        # Pattern: N, n, (Segment)*
        # Segment: ticks, n, (point)*

        data = []

        # pack up header
        data += tobytes(self.waveID, 2)
        data += tobytes(self.E_final, 2)
        data += tobytes(self.wave_type, 1)
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)

        # pack up patterns
        for pattern in self.patterns:
            data += pattern.marshall()

        return bytearray(data)

class Pattern:

    wave = None         # reference to parent wave
    
    N = None            # number of times to repeat this pattern
    n = None            # number of segments in this pattern

    segments = []       # container for segments

    def __init__(self, N=None, n=None):
        self.N = N
        self.n = n
        self.segments = []

    def add_segment(self, segment):
        segment.pattern = self
        self.segments.append(segment)

    def marshall(self):
        data = []
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)
        for segment in self.segments:
            data += segment.marshall()
        return data

class Segment:

    pattern = None      # reference to parent pattern

    ticks = 0           # number of ticks between points
    n = 0               # number of points in this segment

    points = []         # container for voltage values

    def __init__(self, ticks=0, n=0, points=[]):
        self.ticks = ticks
        self.n = n
        self.points = points

    def add_points(self, points):
        self.points += points

    def marshall(self):
        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.n, 2)
        for point in self.points:
            self.pattern.wave.points.append(point)
            data += tobytes(point, 2)
        return data

class LinearSegment:

    pattern = None      # reference to parent pattern

    ticks = None        # number of ticks between points
    s = None            # starting voltage point
    e = None            # ending voltage point

    def __init__(self, ticks=None, s=None, e=None):
        self.ticks = ticks
        self.s = s
        self.e = e

    def marshall(self):
        # calculate points for data file
        v = self.s * 1000           # current voltage in uV
        while v != self.e * 1000:
            self.pattern.wave.points.append(v)
            if v < self.e * 1000:
                v += self.pattern.wave.experiment.device.min_step
            else:
                v -= self.pattern.wave.experiment.device.min_step

        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.s, 2)
        data += tobytes(self.e, 2)
        return data
