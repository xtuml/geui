#mathematical representation of waveform
from util import tobytes

class Wave:

    waveID = None       # key generated by security functions
    E_final = None      # voltage at end of experiment
    wave_type = None    # type of wave sent whether all the points or just end points
    N = None            # number of times to repeat this wave
    n = None            # number of patterns in this wave

    patterns = []       # container for wave patterns

    points = []         # container for points to match up with current values in a data file

    def __init__(self, waveID=None, E_final=None, wave_type=None, N=None, n=None):
        self.waveID = waveID
        self.E_final = E_final
        self.wave_type = wave_type
        self.N = N
        self.n = n
        self.patterns = []

    def add_pattern(self, pattern):
        self.patterns.append(pattern)

    def marshall(self): #pack up wave into an array of values

        # Wave marshalling documentation:
        # Wave: waveID, E_final, N, n, (Pattern)*
        # Pattern: N, n, (Segment)*
        # Segment: ticks, n, (point)*

        data = []

        #pack up header
        data += tobytes(self.waveID, 2)
        data += tobytes(self.E_final, 2)
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)

        #pack up patterns
        for pattern in self.patterns:
            data += pattern.marshall()

        return bytearray(data)

class Pattern:
    
    N = None            #number of times to repeat this pattern
    n = None            #number of segments in this pattern

    segments = []       #container for segments

    def __init__(self, N=None, n=None):
        self.N = N
        self.n = n
        self.segments = []

    def add_segment(self, segment):
        self.segments.append(segment)

    def marshall(self):
        data = []
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)
        for segment in self.segments:
            data += segment.marshall()
        return data

class Segment:

    ticks = None        # number of ticks between points
    n = None            # number of points in this segment

    points = []         # container for voltage values

    def __init__(self, ticks=None, n=None, points=[]):
        self.ticks = ticks
        self.n = n
        self.points = points

    def add_points(self, points):
        self.points += points

    def marshall(self):
        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.n, 2)
        for point in self.points:
            data += tobytes(point, 2)
        return data

class LinearSegment:

    ticks = None        # number of ticks between points
    s = None            # starting voltage point
    e = None            # ending voltage point

    points = []         # container for voltage values

    def __init__(self, ticks=None, s=None, e=None):
        self.ticks = ticks
        self.s = s
        self.e = e

    def marshall(self):
        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.s, 2)
        data += tobytes(self.e, 2)
        return data
