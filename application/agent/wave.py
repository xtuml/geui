# --------------------------------------------------------------------------------------------- #
#   wave.py                                                                                     #
#                                                                                               #
#   Classes defined in this file:                                                               #
#       * Wave                                                                                  #
#       * Pattern                                                                               #
#       * Segment                                                                               #
#       * LinearSegment                                                                         #
# --------------------------------------------------------------------------------------------- #

from util import tobytes

# --------------------------------------------------------------------------------------------- #
#   Wave class                                                                                  #
#                                                                                               #
#   The Wave class defines the waveform representation easy to understand by the device. It     #
#   consists of header information and patterns. The marshall() method packages it into a byte  #
#   array  according the the file formats documentation.                                        #
# --------------------------------------------------------------------------------------------- #
class Wave:
    
    experiment = None   # reference to the experiment this wave belongs to

    waveID = None       # key generated by security functions
    E_final = None      # voltage at end of experiment
    wave_type = None    # type of wave sent whether all the points or just end points
    N = None            # number of times to repeat this wave
    n = None            # number of patterns in this wave

    patterns = []       # container for wave patterns

    points = []         # container for points to match up with current values in a data file

    def __init__(self, waveID=None, E_final=None, wave_type=None, N=None, n=None):
        self.waveID = waveID
        self.E_final = E_final
        self.wave_type = wave_type
        self.N = N
        self.n = n
        self.patterns = []

    def add_pattern(self, pattern):
        pattern.wave = self
        self.patterns.append(pattern)

    def marshall(self): #pack up wave into an array of values

        # Wave marshalling documentation:
        # Wave: waveID, E_final, N, n, (Pattern)*
        # Pattern: N, n, (Segment)*
        # Segment: ticks, n, (point)*

        data = []

        # pack up header
        data += tobytes(self.waveID, 2)
        data += tobytes(self.E_final, 2)
        data += tobytes(self.wave_type, 1)
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)

        # pack up patterns
        for pattern in self.patterns:
            data += pattern.marshall()

        return bytearray(data)
# --------------------------------------------------------------------------------------------- #


# --------------------------------------------------------------------------------------------- #
#   Pattern class                                                                               #
#                                                                                               #
#   The Pattern class defines a distinct repeating set of segments. A Wave object has one or    #
#   more Patterns. Each Pattern has one or more segments. Segments can be either Segment or     #
#   LinearSegment objects.                                                                      #
# --------------------------------------------------------------------------------------------- #
class Pattern:

    wave = None         # reference to parent wave
    
    N = None            # number of times to repeat this pattern
    n = None            # number of segments in this pattern

    segments = []       # container for segments

    def __init__(self, N=None, n=None):
        self.N = N
        self.n = n
        self.segments = []

    def add_segment(self, segment):
        segment.pattern = self
        self.segments.append(segment)

    def marshall(self):
        data = []
        data += tobytes(self.N, 2)
        data += tobytes(self.n, 1)
        for segment in self.segments:
            data += segment.marshall()
        return data
# --------------------------------------------------------------------------------------------- #


# --------------------------------------------------------------------------------------------- #
#   Segment class                                                                               #
#                                                                                               #
#   The Segment class defines a set of points to be played by the device. Each point is just    #
#   a single voltage value. Potentials are measured in counts of device minimum step.           #
# --------------------------------------------------------------------------------------------- #
class Segment:

    pattern = None      # reference to parent pattern

    ticks = 0           # number of ticks between points
    n = 0               # number of points in this segment

    points = []         # container for voltage values

    def __init__(self, ticks=0, n=0, points=[]):
        self.ticks = ticks
        self.n = n
        self.points = points

    def add_points(self, points):
        self.points += points

    def marshall(self):
        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.n, 2)
        for point in self.points:
            self.pattern.wave.points.append(point)
            data += tobytes(point, 2)
        return data
# --------------------------------------------------------------------------------------------- #


# --------------------------------------------------------------------------------------------- #
#   LinearSegment class                                                                         #
#                                                                                               #
#   The LinearSegment class defines a set of points to be played by the device. The segment is  #
#   declared linear so the segment is defined by a starting voltage, an ending voltage and the  #
#   number of ticks. Potentials are measued in count of device minimum step.                    #
# --------------------------------------------------------------------------------------------- #
class LinearSegment:

    pattern = None      # reference to parent pattern

    ticks = 0           # number of ticks between points
    s = 0               # starting voltage point
    e = 0               # ending voltage point

    def __init__(self, ticks=None, s=None, e=None):
        self.ticks = ticks
        self.s = s
        self.e = e

    def marshall(self):
        # calculate points for data file
        v = self.s * 1000           # current voltage in uV
        while v != self.e * 1000:
            self.pattern.wave.points.append(v)
            if v < self.e * 1000:
                v += self.pattern.wave.experiment.device.min_step
            else:
                v -= self.pattern.wave.experiment.device.min_step

        data = []
        data += tobytes(self.ticks, 2)
        data += tobytes(self.s, 2)
        data += tobytes(self.e, 2)
        return data
# --------------------------------------------------------------------------------------------- #
